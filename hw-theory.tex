\documentclass[10pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{stmaryrd}
\usepackage{cmll}
\usepackage{mathrsfs}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{proof}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{mathabx}
\usepackage{comment}
\usepackage{hyperref}
\usepackage[normalem]{ulem}

\makeatletter
\newcommand{\dotminus}{\mathbin{\text{\@dotminus}}}

\newcommand{\@dotminus}{%
  \ooalign{\hidewidth\raise1ex\hbox{.}\hidewidth\cr$\m@th-$\cr}%
}
\makeatother

\usetikzlibrary{arrows,backgrounds,patterns,matrix,shapes,fit,calc,shadows,plotmarks}

\newtheorem{definition}{Определение}
\newtheorem{theorem}{Теорема}
\begin{document}

\begin{center}{\Large\textsc{\textbf{Теоретические домашние задания}}}\\
             \it Математическая логика, ИТМО, М3232-М3239, осень 2023 года\end{center}

\section*{Задание №1. Знакомство с исчислением высказываний.}

Справочное изложение теории, частично разобранной на лекции.

\begin{definition}
Аксиомой является любая формула исчисления высказываний, которая может быть получена из следующих схем аксиом:

\begin{tabular}{ll}
(1) & $\alpha \rightarrow \beta \rightarrow \alpha$ \\
(2) & $(\alpha \rightarrow \beta) \rightarrow (\alpha \rightarrow \beta \rightarrow \gamma) \rightarrow (\alpha \rightarrow \gamma)$ \\
(3) & $\alpha \rightarrow \beta \rightarrow \alpha \& \beta$\\
(4) & $\alpha \& \beta \rightarrow \alpha$\\
(5) & $\alpha \& \beta \rightarrow \beta$\\
(6) & $\alpha \rightarrow \alpha \vee \beta$\\
(7) & $\beta \rightarrow \alpha \vee \beta$\\
(8) & $(\alpha \rightarrow \gamma) \rightarrow (\beta \rightarrow \gamma) \rightarrow (\alpha \vee \beta \rightarrow \gamma)$\\
(9) & $(\alpha \rightarrow \beta) \rightarrow (\alpha \rightarrow \neg \beta) \rightarrow \neg \alpha$\\
(10) & $\neg \neg \alpha \rightarrow \alpha$
\end{tabular}
\end{definition}

\begin{definition}
Выводом из гипотез $\gamma_1,\dots,\gamma_n$ назовём конечную непустую последовательность высказываний $\delta_1, \dots, \delta_t$, для каждого из которых
выполнено хотя бы что-то из списка:
\begin{enumerate}
\item высказывание является аксиомой;
\item высказывание получается из предыдущих по правилу Modus Ponens (то есть, для высказывания $\delta_i$ найдутся
такие $\delta_j$ и $\delta_k$, что $j,k < i$ и $\delta_k \equiv \delta_j \rightarrow \delta_i$);
\item высказывание является гипотезой (то есть, является одной из формул $\gamma_1,\dots,\gamma_n$).
\end{enumerate}
\end{definition}

\begin{definition}
Будем говорить, что формула $\alpha$ выводится (доказывается) из гипотез $\gamma_1,\dots,\gamma_n$ 
(и записывать это как $\gamma_1,\dots,\gamma_n\vdash\alpha$), если существует такой вывод
из гипотез $\gamma_1,\dots,\gamma_n$, что последней формулой которого является формула $\alpha$.
\end{definition}

Заметим, что доказательство формулы $\alpha$ --- это вывод формулы $\alpha$ из
пустого множества гипотез.

При решении заданий вам может потребоваться теорема о дедукции (будет доказана на второй лекции): 
\begin{theorem}
$\gamma_1,\dots,\gamma_n, \alpha \vdash \beta$ 
тогда и только тогда, когда $\gamma_1,\dots,\gamma_n \vdash \alpha\rightarrow\beta$. 
\end{theorem}

Пример использования: пусть необходимо доказать $\vdash A \rightarrow A$ --- то есть
доказать существование вывода формулы $A \rightarrow A$ (заметьте, так поставленное
условие не требует этот вывод предъявлять, только доказать его существование).
Тогда заметим, что последовательность из одной формулы $A$ доказывает $A \vdash A$. 
Далее, по теореме о дедукции, отсюда следует и $\vdash A \rightarrow A$ 
(то есть, вывода формулы $A \rightarrow A$, не использующего гипотезы).

\begin{enumerate}
\item Докажите:
\begin{enumerate}
\item $\vdash (A \rightarrow A \rightarrow B) \rightarrow (A \rightarrow B)$
\item $\vdash \neg (A \with \neg A)$
\item $\vdash A \with B \rightarrow B \with A$
\item $\vdash A \vee B \rightarrow B \vee A$
\item $A \with \neg A \vdash B$
\end{enumerate}

\item Докажите:
\begin{enumerate}
\item $\vdash A \rightarrow \neg \neg A$
\item $\neg A, B \vdash \neg(A\& B)$
\item $\neg A,\neg B \vdash \neg( A\vee B)$
\item $ A,\neg B \vdash \neg( A\rightarrow B)$
\item $\neg A, B \vdash  A\rightarrow B$
\end{enumerate}

\item Докажите:
\begin{enumerate}
\item $\vdash (A \rightarrow B) \rightarrow (B \rightarrow C) \rightarrow (A \rightarrow C)$ 
\item $\vdash (A \rightarrow B) \rightarrow (\neg B \rightarrow \neg A)$ \emph{(правило контрапозиции)}
\item $\vdash \neg (\neg A \with \neg B) \rightarrow (A \vee B)$ \emph{(вариант I закона де Моргана)}
\item $\vdash (\neg A \vee \neg B) \rightarrow \neg (A \with B)$ \emph{(II закон де Моргана)}
\item $\vdash (A \rightarrow B) \rightarrow (\neg A \vee B)$
\item $\vdash A \with B \rightarrow A \vee B$
\item $\vdash ((A \rightarrow B) \rightarrow A)\rightarrow A$ \emph{(закон Пирса)}
\item $\vdash A \vee \neg A$
\item $\vdash (A \with B \rightarrow C) \rightarrow (A \rightarrow B \rightarrow C)$
\item $\vdash (A \rightarrow B \rightarrow C) \rightarrow (A \with B \rightarrow C)$
\item $\vdash (A \rightarrow B) \vee (B \rightarrow A)$
\item $\vdash (A \rightarrow B) \vee (B \rightarrow C) \vee (C \rightarrow A)$
\end{enumerate}

\item Даны высказывания $\alpha$ и $\beta$, причём $\vdash \alpha\rightarrow\beta$ и $\not\vdash\beta\rightarrow\alpha$. 
Укажите способ построения высказывания $\gamma$, такого, что
$\vdash\alpha\rightarrow\gamma$ и $\vdash\gamma\rightarrow\beta$, причём $\not\vdash\gamma\rightarrow\alpha$ и
$\not\vdash\beta\rightarrow\gamma$.

\item Покажите, что если $\alpha \vdash \beta$ и $\neg\alpha\vdash\beta$, то $\vdash\beta$.
\end{enumerate}

\section*{Задание №2. Теоремы об исчислении высказываний. Знакомство с интуиционистским исчислением высказываний.}
\begin{enumerate}
\item (только для очной практики) на память приведите греческий алфавит --- запишите на доске в алфавитном порядке все большие и маленькие
греческие буквы и назовите их.
\item Давайте вспомним, что импликация правоассоциативна: $\alpha\rightarrow\beta\rightarrow\gamma \equiv \alpha\rightarrow(\beta\rightarrow\gamma)$.
Но рассмотрим иную расстановку скобок: $(\alpha\rightarrow\beta)\rightarrow\gamma$. Возможно ли доказать логическое следствие
между этими вариантами расстановки скобок --- и каково его направление?
\item Покажите, что в классическом исчислении высказываний $\Gamma \models \alpha$ влечёт $\Gamma \vdash \alpha$.
\item Покажите, что в классическом исчислении высказываний $\Gamma \vdash \alpha$ влечёт $\Gamma \models \alpha$.
\item Возможно ли, что какая-то из аксиом задаётся двумя разными схемами аксиом? Опишите все возможные коллизии, если они есть.
Ответ обоснуйте (да, тут потребуется доказательство по индукции).

\item Заметим, что можно вместо отрицания ввести в исчисление ложь. Рассмотрим \emph{исчисление высказываний с ложью}.
В этом языке будет отсутствовать одноместная связка $(\neg)$, вместо неё будет присутствовать нульместная
связка <<ложь>> $(\bot)$, а 9 и 10 схемы аксиом будут заменены на одну схему:

\begin{tabular}{ll}
$(9_\bot)$ & $((\alpha\rightarrow\bot)\rightarrow\bot)\rightarrow\alpha$
\end{tabular}

Будем записывать доказуемость в новом исчислении как $\vdash_\bot \alpha$, а доказуемость в исчислении высказываний
с отрицанием как $\vdash_\neg \beta$.

Определим операцию трансляции между языками обычного исчисления высказываний и исчисления с ложью
как операции рекурсивной замены $\bot := A \with \neg A$ и $\neg \alpha := \alpha \rightarrow \bot$ (и обозначим их
как $|\varphi|_\neg$ и $|\psi|_\bot$ соответственно), то:
\begin{enumerate}
\item $\vdash_\bot \alpha$ влечёт $\vdash_\neg |\alpha|_\neg$
\item $\vdash_\neg \alpha$ влечёт $\vdash_\neg |\alpha|_\bot$
\end{enumerate}


\item Изоморфизм Карри-Ховарда --- соответствие между логическими исчислениями (например, исчислением высказываний), с одной стороны, и 
языками программирования, с другой. А именно, можно заметить, что программа соответствует доказательству, тип программы --- 
логическому высказыванию. Связки (как составные части логического высказывания) соответствуют определённым типовым конструкциям:
функция --- импликации, конъюнкция --- упорядоченной паре, дизъюнкция --- алгебраическому типу (\verb!std::variant! и т.п.).
Атомарным высказываниям мы сопоставим элементарные типы. Понятие же доказуемости превращается в \emph{обитаемость} типа.
Например, доказать обитаемость типа \verb!int! возможно, предъявив значение этого типа: \verb!5!.

Функция \verb!A id(A x) { return x; }! доказывает $A \rightarrow A$, а функция 
\begin{verbatim}
std::pair<A,B> swap(std::pair<B,A> x) { return std::pair(x.second, x.first); }
\end{verbatim}
доказывает $B\with A \rightarrow A \with B$. В самом деле, данные функции являются элементами соответствующих
типов, поэтому их можно понимать как доказательства соответствующих типам логических выражений.

Ложь --- это необитаемый тип; тип, не имеющий значений. В некоторых языках такие типы можно выписать
явно. Например, в Хаскеле можно построить алгебраический тип без конструкторов:

\begin{verbatim}
data False
main = do print "Hi"
\end{verbatim}

В других (например, в C++) эти значения можно сымитировать. Например, в одних случаях сделать параметром темплейта.
Тогда, если мы никаких ограничений на этот параметр не делаем, кто-то мог бы подставить и необитаемый тип вместо этого параметра:

\begin{verbatim}
template <class Bot>
Bot (*contraposition (A a)) (A a, B b, Bot (*neg_b) (B));
\end{verbatim}

В самом деле, $(A \rightarrow B) \rightarrow ((B \rightarrow \bot) \rightarrow (A \rightarrow \bot))$ есть частный
случай $(A \rightarrow B) \rightarrow ((B \rightarrow \alpha) \rightarrow (A \rightarrow \alpha))$, который тоже можно доказать.

В некоторых случаях можно воспользоваться конструкцией, не возвращающей управления, которая \emph{понятна компилятору}. Например, 
можно так задать правило удаления лжи ($\bot\rightarrow A$):

\begin{verbatim}
template <class Bot>
A remove_bot(Bot x) { throw x; }

int a = remove_bot<int> (...);
char* b = remove_bot<char*> (...);
char(*c)() = remove_bot<char(*)()> (...);
\end{verbatim}

В заверешние теоретической части заметим, что 
\begin{itemize}
\item логика, которая получится, если мы будем играть в эту игру честно --- это уже будет не классическая логика; для неё не будут справедливы все
схемы аксиом, 10 схема будет нарушаться;
\item большинство языков программирования противоречивы в смысле логической теории; в частности, там можно доказать ложь.
Но для того, чтобы это получилось, вам обычно требуется использовать либо инструменты обхода ограничений типовой системы
(например, явные приведения типов), либо конструкции, не возвращающие управления: бесконечная рекурсия, исключения и т.п.
\end{itemize}

Докажите следующие утверждения, написав соответствующую программу на выбранном вами языке программирования,
не используя противоречивости его типовой системы (кроме последнего задания). В случае C++ можно также
использовать правило удаления лжи, указанное выше; для других языков при необходимости можно выделить какое-то похожее правило:
\begin{enumerate}
\item $A \rightarrow B \rightarrow A$
\item $A \with B \rightarrow A \vee B$
\item $(A \with (B \vee C)) \rightarrow ((A \with B) \vee (A \with C))$
\item $(A \rightarrow C) \with (B \rightarrow C) \with (A \vee B) \rightarrow C$
\item $(B \vee C \rightarrow A) \rightarrow (B \rightarrow A) \with (C \rightarrow A)$
\item $(A \rightarrow B) \rightarrow (\neg B \rightarrow \neg A)$
\item $((A \rightarrow B) \rightarrow C) \rightarrow (A \rightarrow (B \rightarrow C))$
\item $(A \rightarrow B) \with (A \rightarrow \neg B) \rightarrow \neg A$
\item Одно из двух утверждений: $(A \rightarrow B) \rightarrow \neg A \vee B$ или
$\neg A \vee B \rightarrow (A \rightarrow B)$. Сразу заметим, что оставшееся утверждение доказать
без использования противоречивости языка не получится.
\item $\bot$ (любым доступным в языке способом)
\end{enumerate}

Для зачёта по пункту условия требуется написать код программы и продемонстрировать его работу на компьютере.
Если вы желаете получить дополнительные 0.5 балла за оформление в Тех-е, вам потребуется оформить в Тех-е 
исходный код программы (подсказка: для языков программирования могут существовать специальные пакеты
для красивого оформления кода).

\end{enumerate}

\end{document}
